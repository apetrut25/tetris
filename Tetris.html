<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Boy Tetris</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            background-color: #d3d3d3; /* Light grey background, like Game Boy plastic */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            color: #0F380F; /* Darkest green for text */
            overflow: hidden; /* Prevent scrollbars from game elements */
        }

        #gameboy-shell {
            background-color: #8c8c8c; /* Game Boy grey */
            padding: 20px;
            border-radius: 10px 10px 50px 10px; /* Gameboy-ish shape */
            box-shadow: 0 10px 20px rgba(0,0,0,0.3), inset 0 0 10px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #screen-bezel {
            background-color: #777; /* Darker grey for screen bezel */
            padding: 15px;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }

        #gameboy-screen {
            background-color: #9BBC0F; /* Lightest green - screen background */
            padding: 10px;
            border: 2px solid #0F380F; /* Darkest green border for screen */
            border-radius: 5px;
            display: flex;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
            width: calc(200px + 120px + 20px); /* board + info + padding */
            height: calc(360px + 20px); /* board height + padding */
            overflow: hidden; /* Ensure nothing spills out */
        }

        #game-container {
            display: flex;
            align-items: flex-start; /* Align items to the top */
        }

        #tetris-board {
            border: 2px solid #0F380F; /* Darkest green border for play area */
            background-color: #9BBC0F; /* Lightest green - game background */
            /* Dimensions set by JS */
        }

        #game-info {
            width: 120px; /* Width for score, level, next piece */
            padding-left: 15px;
            font-size: 12px; /* Smaller font for info panel */
            line-height: 1.6;
            color: #0F380F; /* Darkest green text */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            height: 100%;
        }

        #game-info div {
            margin-bottom: 10px;
        }
        
        #game-info span {
            display: block; /* Make spans take full width for alignment */
            text-align: right;
            padding-right: 5px;
        }

        #next-piece-container {
            margin-top: 10px;
        }

        #next-piece-canvas {
            border: 1px solid #306230; /* Dark green border */
            background-color: #8BAC0F; /* Light green background for next piece */
            display: block;
            margin-top: 5px;
            /* Dimensions set by JS */
        }
        
        #title-header {
            font-size: 16px;
            color: #0F380F;
            margin-bottom: 5px;
            text-align: center;
        }

        #controls {
            margin-top: 10px; /* Space between screen and controls */
            display: flex;
            gap: 10px;
        }

        #controls button, .action-button {
            font-family: 'Press Start 2P', cursive;
            background-color: #555; /* Dark grey buttons */
            color: #ddd; /* Light text on buttons */
            border: 2px solid #333;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 0 #333, 0 4px 5px rgba(0,0,0,0.3);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.1s ease;
            text-transform: uppercase;
        }

        #controls button:active, .action-button:active {
            background-color: #444;
            box-shadow: 0 1px 0 #333;
            transform: translateY(1px);
        }
        
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(15, 56, 15, 0.9); /* Dark green, slightly transparent */
            color: #9BBC0F; /* Light green text */
            padding: 20px;
            border: 3px solid #306230; /* Medium green border */
            border-radius: 5px;
            font-size: 16px;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        .hidden {
            display: none !important;
        }

        /* D-pad and action buttons styling */
        #gameboy-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 300px; /* Approximate width for controls */
            margin-top: 20px;
        }

        #d-pad {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-template-rows: repeat(3, 40px);
            gap: 2px;
        }

        .d-pad-btn {
            background-color: #333; /* Darker buttons for D-pad */
            border: 1px solid #222;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9BBC0F;
            font-size: 18px;
            cursor: pointer;
            user-select: none; /* Prevent text selection on hold */
        }
        .d-pad-btn:active {
            background-color: #222;
        }

        #d-pad-up { grid-column: 2; grid-row: 1; }
        #d-pad-left { grid-column: 1; grid-row: 2; }
        #d-pad-center { grid-column: 2; grid-row: 2; background-color: #444; } /* Center piece */
        #d-pad-right { grid-column: 3; grid-row: 2; }
        #d-pad-down { grid-column: 2; grid-row: 3; }

        #action-buttons {
            display: flex;
            flex-direction: column; /* Stack A and B buttons */
            gap: 10px;
        }

        .action-button { /* Re-using for A/B */
            width: 60px;
            height: 60px;
            border-radius: 50%; /* Round buttons */
            background-color: #a04050; /* Reddish buttons like Game Boy */
            color: #fff;
            font-size: 20px;
            line-height: 56px; /* Center text (adjust for border) */
            text-align: center;
            user-select: none; /* Prevent text selection on hold */
        }
        .action-button.b { /* Specific style for B if needed, otherwise inherits from .action-button */
             background-color: #903040; /* Slightly different shade for B */
        }


        /* Responsive adjustments */
        @media (max-width: 600px) {
            #gameboy-shell {
                padding: 10px;
                transform: scale(0.9); /* Scale down slightly on small screens */
            }
            #screen-bezel {
                padding: 10px;
            }
            #gameboy-screen {
                width: calc(100vw - 60px); 
                max-width: calc(200px + 120px + 20px); 
                height: auto;
                flex-direction: column; 
                align-items: center;
            }
            #game-container {
                flex-direction: column;
                align-items: center;
            }
            #game-info {
                width: 100%;
                padding-left: 0;
                margin-top: 10px;
                text-align: center;
            }
            #game-info span {
                text-align: center;
            }
            #next-piece-container {
                margin: 10px auto;
            }
            #next-piece-canvas {
                margin: 5px auto;
            }

            #gameboy-controls {
                flex-direction: column;
                gap: 15px;
                width: 100%;
            }
            #controls { 
                order: 2; 
            }
            #d-pad {
                order: 1;
            }
            #action-buttons {
                order: 0;
                flex-direction: row; 
            }
        }

    </style>
</head>
<body>
    <div id="gameboy-shell">
        <div id="screen-bezel">
            <div id="title-header">TETRIS</div>
            <div id="gameboy-screen">
                <div id="game-container">
                    <canvas id="tetris-board"></canvas>
                    <div id="game-info">
                        <div>SCORE<span id="score">0</span></div>
                        <div>LEVEL<span id="level">0</span></div>
                        <div>LINES<span id="lines-cleared">0</span></div>
                        <div id="next-piece-container">
                            NEXT:
                            <canvas id="next-piece-canvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="message-box" class="hidden"></div>
        <div id="controls">
            <button id="start-button">START</button>
            <button id="pause-button">PAUSE</button>
        </div>
        <div id="gameboy-controls">
            <div id="d-pad">
                <button class="d-pad-btn" id="d-pad-up" title="Rotate">▲</button>
                <button class="d-pad-btn" id="d-pad-left" title="Move Left">◀</button>
                <div class="d-pad-btn" id="d-pad-center"></div>
                <button class="d-pad-btn" id="d-pad-right" title="Move Right">▶</button>
                <button class="d-pad-btn" id="d-pad-down" title="Move Down">▼</button>
            </div>
            <div id="action-buttons">
                <button class="action-button b" id="action-b" title="Rotate">B</button>
                <button class="action-button a" id="action-a" title="Rotate">A</button>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('tetris-board');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-piece-canvas');
        const nextContext = nextCanvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const linesClearedElement = document.getElementById('lines-cleared');
        const messageBox = document.getElementById('message-box');
        const startButton = document.getElementById('start-button');
        const pauseButton = document.getElementById('pause-button');
        const dPadDown = document.getElementById('d-pad-down');

        // Game constants
        const COLS = 10;
        const ROWS = 18; 
        const BLOCK_SIZE = 20; 
        const NEXT_COLS = 4;
        const NEXT_ROWS = 4;
        const FAST_DROP_INTERVAL = 2; // Frames for accelerated drop
        const INITIAL_BPM = 120; // Starting BPM for theme music
        const BPM_INCREMENT_PER_LEVEL = 10; // How much BPM increases per level

        // Game Boy Colors
        const COLORS = {
            BACKGROUND: '#9BBC0F', 
            GRID_LINES: '#8BAC0F',  
            BLOCK: '#0F380F',      
            TEXT: '#0F380F',
            PIECE_SHADOW: '#306230' 
        };

        // Tetrominoes
        const TETROMINOES = {
            'I': { shape: [[1,1,1,1]], color: COLORS.BLOCK, x: 0, y: 0 },
            'J': { shape: [[1,0,0], [1,1,1]], color: COLORS.BLOCK, x: 0, y: 0 },
            'L': { shape: [[0,0,1], [1,1,1]], color: COLORS.BLOCK, x: 0, y: 0 },
            'O': { shape: [[1,1], [1,1]], color: COLORS.BLOCK, x: 1, y: 1 },
            'S': { shape: [[0,1,1], [1,1,0]], color: COLORS.BLOCK, x: 0, y: 1 },
            'T': { shape: [[0,1,0], [1,1,1]], color: COLORS.BLOCK, x: 0, y: 1 },
            'Z': { shape: [[1,1,0], [0,1,1]], color: COLORS.BLOCK, x: 0, y: 1 }
        };
        const PIECE_KEYS = Object.keys(TETROMINOES);

        // Game state variables
        let board;
        let currentPiece;
        let nextPiece;
        let score;
        let level;
        let linesCleared;
        let dropCounter;
        let dropInterval; 
        let gameOver;
        let paused;
        let gameLoopId;
        let audioInitialized = false;
        let isFastDropping = false; // For accelerated drop

        // Sound Synthesis (Tone.js)
        let moveSound, rotateSound, landSound, lineClearSound, tetrisSound, gameOverSound, levelUpSound;
        let themeMusicSynth, themeMusicSequence;

        // Korobeiniki (Tetris Theme A) - simplified
        // Format: { time: "measure:beat:sixteenth", note, duration }
        // Or array of [time, note, duration] for Tone.Part, or notes for Tone.Sequence
        const tetrisMelody = [
            { time: '0:0:0', note: 'E5', duration: '4n' }, { time: '0:1:0', note: 'B4', duration: '8n' }, { time: '0:1:2', note: 'C5', duration: '8n' },
            { time: '0:2:0', note: 'D5', duration: '4n' }, { time: '0:3:0', note: 'C5', duration: '8n' }, { time: '0:3:2', note: 'B4', duration: '8n' },
            { time: '0:4:0', note: 'A4', duration: '4n' }, { time: '0:5:0', note: 'A4', duration: '8n' }, { time: '0:5:2', note: 'C5', duration: '8n' },
            { time: '0:6:0', note: 'E5', duration: '4n' }, { time: '0:7:0', note: 'D5', duration: '8n' }, { time: '0:7:2', note: 'C5', duration: '8n' },
            { time: '1:0:0', note: 'B4', duration: '2n' }, { time: '1:2:0', note: 'C5', duration: '4n' },
            { time: '1:3:0', note: 'D5', duration: '2n' }, { time: '1:5:0', note: 'E5', duration: '2n' },
            { time: '2:0:0', note: 'C5', duration: '2n' }, { time: '2:2:0', note: 'A4', duration: '2n' },
            { time: '2:4:0', note: 'A4', duration: '1n' }, // Held note

            { time: '3:0:0', note: 'D5', duration: '4n.' }, { time: '3:1:2', note: 'F5', duration: '8n' }, { time: '3:2:0', note: 'A5', duration: '2n' },
            { time: '3:4:0', note: 'G5', duration: '8n' }, { time: '3:4:2', note: 'F5', duration: '8n' }, { time: '3:5:0', note: 'E5', duration: '2n.' }, // Dotted half
            { time: '4:0:0', note: 'C5', duration: '4n.' }, { time: '4:1:2', note: 'E5', duration: '8n' }, { time: '4:2:0', note: 'D5', duration: '8n' }, { time: '4:2:2', note: 'C5', duration: '8n' },
            { time: '4:3:0', note: 'B4', duration: '2n' }, { time: '4:5:0', note: 'C5', duration: '4n' },
            { time: '4:6:0', note: 'D5', duration: '2n' }, { time: '5:0:0', note: 'E5', duration: '2n' },
            { time: '5:2:0', note: 'C5', duration: '2n' }, { time: '5:4:0', note: 'A4', duration: '2n' },
            { time: '6:0:0', note: 'A4', duration: '1n' }
        ];


        function initSounds() {
            if (audioInitialized) return;
            try {
                moveSound = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
                rotateSound = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
                landSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                lineClearSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
                tetrisSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "pulse", width: 0.3 }, envelope: { attack: 0.01, decay: 0.4, sustain: 0.2, release: 0.3 } }).toDestination();
                gameOverSound = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.1, decay: 0.5, sustain: 0, release: 0.5 } }).toDestination();
                levelUpSound = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.05, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination();

                // Theme Music Synth
                themeMusicSynth = new Tone.Synth({
                    oscillator: { type: 'pulse', width: 0.4 }, // Gameboy-ish pulse wave
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.1 }
                }).toDestination();
                themeMusicSynth.volume.value = -12; // Lower volume for background music

                // Theme Music Sequence
                themeMusicSequence = new Tone.Sequence((time, noteEvent) => {
                    themeMusicSynth.triggerAttackRelease(noteEvent.note, noteEvent.duration, time);
                }, tetrisMelody, "4n"); // "4n" is the interval between events if not specified in time
                themeMusicSequence.loop = true;
                Tone.Transport.bpm.value = INITIAL_BPM;

                audioInitialized = true;
            } catch (e) {
                console.error("Failed to initialize audio:", e);
                audioInitialized = false; 
            }
        }

        function playSound(sound, note, duration = "16n", time = "+0") {
            if (audioInitialized && sound && Tone.context.state === 'running') {
                if (sound instanceof Tone.PolySynth) {
                    sound.triggerAttackRelease(note, duration, Tone.now() + parseFloat(time));
                } else {
                    sound.triggerAttackRelease(note, duration, Tone.now() + parseFloat(time));
                }
            }
        }


        // Game board setup
        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        // Tetromino functions
        function getRandomPiece() {
            const randIndex = Math.floor(Math.random() * PIECE_KEYS.length);
            const key = PIECE_KEYS[randIndex];
            const pieceData = TETROMINOES[key];
            const shape = pieceData.shape.map(row => row.slice()); 
            return {
                shape: shape,
                color: pieceData.color,
                x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0 
            };
        }

        function rotate(piece) {
            const N = piece.shape.length;
            const M = piece.shape[0].length;
            const newShape = Array.from({ length: M }, () => Array(N).fill(0));
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < M; c++) {
                    if (piece.shape[r][c]) {
                        newShape[c][N - 1 - r] = piece.shape[r][c];
                    }
                }
            }
            piece.shape = newShape;
        }

        // Collision detection
        function checkCollision(piece, board, offsetX = 0, offsetY = 0) {
            const shape = piece.shape;
            const x = piece.x + offsetX;
            const y = piece.y + offsetY;

            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c]) {
                        const boardX = x + c;
                        const boardY = y + r;
                        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) return true;
                        if (boardY >= 0 && board[boardY] && board[boardY][boardX]) return true;
                    }
                }
            }
            return false;
        }

        // Lock piece onto board
        function lockPiece() {
            currentPiece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) {
                        const boardX = currentPiece.x + c;
                        const boardY = currentPiece.y + r;
                        if (boardY >= 0) {
                           board[boardY][boardX] = currentPiece.color;
                        }
                    }
                });
            });
            if (audioInitialized) playSound(landSound, "C3");
        }

        // Line clearing
        function clearLines() {
            let linesClearedThisTurn = 0;
            for (let r = ROWS - 1; r >= 0; ) {
                if (board[r].every(cell => cell !== 0)) {
                    linesClearedThisTurn++;
                    linesCleared++;
                    board.splice(r, 1); 
                    board.unshift(Array(COLS).fill(0)); 
                } else {
                    r--; 
                }
            }

            if (linesClearedThisTurn > 0) {
                updateScore(linesClearedThisTurn);
                updateLevel();
                if (audioInitialized) {
                    if (linesClearedThisTurn === 4) {
                        playSound(tetrisSound, ["C4", "E4", "G4", "C5"], "2n");
                    } else {
                         playSound(lineClearSound, ["C5", "E5", "G5"], "8n");
                    }
                }
            }
        }

        // Scoring
        function updateScore(clearedCount) {
            const points = [0, 40, 100, 300, 1200]; 
            score += points[clearedCount] * (level + 1);
            scoreElement.textContent = score;
        }

        // Leveling
        function updateLevel() {
            const newLevel = Math.floor(linesCleared / 10); 
            if (newLevel > level) {
                level = newLevel;
                levelElement.textContent = level;
                const levelSpeeds = [48, 43, 38, 33, 28, 23, 18, 13, 8, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1];
                dropInterval = levelSpeeds[Math.min(level, levelSpeeds.length - 1)] || 1;

                if (audioInitialized && Tone.context.state === 'running') {
                    Tone.Transport.bpm.value = INITIAL_BPM + (level * BPM_INCREMENT_PER_LEVEL);
                    playSound(levelUpSound, "A4", "4n");
                }
                showMessage(`LEVEL ${level + 1}!`, 1000);
            }
            linesClearedElement.textContent = linesCleared;
        }


        // Drawing functions
        function drawBlock(x, y, color, ctx = context, bs = BLOCK_SIZE) {
            ctx.fillStyle = color;
            ctx.fillRect(x * bs, y * bs, bs, bs);
            ctx.fillStyle = COLORS.PIECE_SHADOW; 
            ctx.fillRect(x * bs + bs - 2, y * bs, 2, bs); 
            ctx.fillRect(x * bs, y * bs + bs - 2, bs, 2); 
            ctx.strokeStyle = COLORS.GRID_LINES; 
            ctx.strokeRect(x * bs, y * bs, bs, bs);
        }

        function drawBoard() {
            context.fillStyle = COLORS.BACKGROUND;
            context.fillRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        drawBlock(c, r, board[r][c]);
                    } else {
                        context.fillStyle = 'rgba(15, 56, 15, 0.1)'; 
                        context.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                }
            }
        }

        function drawPiece(piece, ctx = context, bs = BLOCK_SIZE, offX = 0, offY = 0) {
            piece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) {
                        drawBlock(piece.x + c + offX, piece.y + r + offY, piece.color, ctx, bs);
                    }
                });
            });
        }
        
        function drawNextPiece() {
            nextContext.fillStyle = COLORS.BACKGROUND; 
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (nextPiece) {
                const pieceDetails = TETROMINOES[PIECE_KEYS.find(k => JSON.stringify(TETROMINOES[k].shape) === JSON.stringify(nextPiece.shape))];
                const shapeWidth = nextPiece.shape[0].length;
                const shapeHeight = nextPiece.shape.length;
                const offsetX = Math.floor((NEXT_COLS - shapeWidth) / 2) - (pieceDetails ? pieceDetails.x : 0);
                const offsetY = Math.floor((NEXT_ROWS - shapeHeight) / 2) - (pieceDetails ? pieceDetails.y : 0);
                const tempPiece = { shape: nextPiece.shape, color: nextPiece.color, x: offsetX, y: offsetY };
                drawPiece(tempPiece, nextContext, BLOCK_SIZE * 0.8, 0, 0); 
            }
        }


        // Game loop
        function gameLoop() { 
            if (gameOver || paused) {
                if (gameLoopId) cancelAnimationFrame(gameLoopId); 
                return;
            }

            let currentDropIntervalForLoop = dropInterval;
            if (isFastDropping) {
                currentDropIntervalForLoop = FAST_DROP_INTERVAL;
            }

            dropCounter++;
            if (dropCounter >= currentDropIntervalForLoop) {
                movePiece(0, 1); 
                dropCounter = 0;
            }

            drawBoard();
            drawPiece(currentPiece);
            drawNextPiece(); 

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Piece movement
        function movePiece(dx, dy) {
            if (gameOver || paused) return;

            if (!checkCollision(currentPiece, board, dx, dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                if (dy > 0 && !isFastDropping) dropCounter = 0; // Reset if normal drop
                else if (dy > 0 && isFastDropping) dropCounter = 0; // Also reset for fast drop to ensure continuous movement
                
                if (dx !== 0 && audioInitialized) playSound(moveSound, "C4", "32n");
            } else if (dy > 0) { 
                lockPiece();
                clearLines();
                currentPiece = nextPiece;
                nextPiece = getRandomPiece();
                drawNextPiece(); 
                if (checkCollision(currentPiece, board)) {
                    endGame();
                } else {
                    currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
                    currentPiece.y = 0; 
                     if (checkCollision(currentPiece, board)) { 
                        endGame();
                    }
                }
            }
        }

        function attemptRotate() {
            if (gameOver || paused) return;
            const originalShape = currentPiece.shape.map(row => row.slice()); 
            const originalX = currentPiece.x;
            const originalY = currentPiece.y;

            rotate(currentPiece);
            if (audioInitialized) playSound(rotateSound, "E4", "16n");

            let offset = 0;
            if (checkCollision(currentPiece, board)) {
                offset = currentPiece.x < COLS / 2 ? 1 : -1; 
                if (!checkCollision(currentPiece, board, offset, 0)) {
                    currentPiece.x += offset;
                } else if (!checkCollision(currentPiece, board, -offset, 0)) { 
                     currentPiece.x -= offset;
                } else if (!checkCollision(currentPiece, board, offset*2, 0)) { 
                     currentPiece.x += offset*2;
                } else if (!checkCollision(currentPiece, board, -offset*2, 0)) {
                     currentPiece.x -= offset*2;
                }
                else { 
                    currentPiece.shape = originalShape;
                    currentPiece.x = originalX;
                    currentPiece.y = originalY;
                }
            }
        }

        // Game flow
        async function startGame() {
            if (!audioInitialized) {
                try {
                    await Tone.start();
                    initSounds();
                    console.log("Audio context started by user gesture.");
                } catch (e) {
                    console.warn("Audio context not started or Tone.js failed:", e);
                }
            } else if (Tone.context.state !== 'running') {
                 try {
                    await Tone.start();
                    console.log("Audio context re-started.");
                 } catch (e) {
                    console.warn("Audio context could not be re-started:", e);
                 }
            }


            board = createBoard();
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            score = 0;
            level = 0;
            linesCleared = 0;
            dropCounter = 0;
            dropInterval = 48; 
            gameOver = false;
            paused = false;
            isFastDropping = false;

            scoreElement.textContent = score;
            levelElement.textContent = level;
            linesClearedElement.textContent = linesCleared;
            messageBox.classList.add('hidden');
            startButton.textContent = "RESTART";
            pauseButton.textContent = "PAUSE";
            pauseButton.disabled = false;

            if (audioInitialized && Tone.context.state === 'running') {
                Tone.Transport.bpm.value = INITIAL_BPM + (level * BPM_INCREMENT_PER_LEVEL);
                if (themeMusicSequence && themeMusicSequence.state !== "started") {
                    themeMusicSequence.start(0);
                }
                if (Tone.Transport.state !== "started") {
                    Tone.Transport.start();
                }
            }


            if (gameLoopId) cancelAnimationFrame(gameLoopId); 
            gameLoop();
        }

        function pauseGame() {
            if (gameOver) return;
            paused = !paused;
            if (paused) {
                if (gameLoopId) cancelAnimationFrame(gameLoopId);
                showMessage('PAUSED');
                pauseButton.textContent = "RESUME";
                if (audioInitialized && Tone.Transport.state === "started") {
                    Tone.Transport.pause();
                }
            } else {
                showMessage('RESUMED', 800);
                pauseButton.textContent = "PAUSE";
                if (audioInitialized && Tone.Transport.state === "paused") {
                    Tone.Transport.start();
                }
                gameLoop(); 
            }
        }

        function endGame() {
            gameOver = true;
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            showMessage('GAME OVER!<br>Score: ' + score, 0, true); 
            if (audioInitialized) {
                playSound(gameOverSound, "G2", "1n");
                if (themeMusicSequence) themeMusicSequence.stop();
                if (Tone.Transport.state !== "stopped") Tone.Transport.stop();
            }
            startButton.textContent = "PLAY AGAIN?";
            pauseButton.disabled = true;
            isFastDropping = false;
        }

        function showMessage(text, duration = 2000, persistent = false) {
            messageBox.innerHTML = text; 
            messageBox.classList.remove('hidden');
            if (!persistent && duration > 0) {
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, duration);
            }
        }

        // Event Listeners
        document.addEventListener('keydown', (e) => {
            if (gameOver && e.key !== 'Enter' && e.key !== ' ') return; 
            if (!currentPiece && e.key !== 'Enter' && e.key !== ' ' && !gameOver) return; 

            if (e.key === 'Enter' || e.key === ' ') {
                 if (gameOver || !gameLoopId && !paused) { 
                    startGame();
                    e.preventDefault();
                    return;
                 }
            }
            
            if (paused && e.key !== 'p' && e.key !== 'P') return; 

            switch (e.key.toLowerCase()) { // Use toLowerCase for case-insensitivity
                case 'arrowleft':
                case 'a':
                    movePiece(-1, 0);
                    e.preventDefault();
                    break;
                case 'arrowright':
                case 'd':
                    movePiece(1, 0);
                    e.preventDefault();
                    break;
                case 'arrowdown':
                case 's':
                    if (!isFastDropping) { // Prevent re-triggering if already fast dropping via key repeat
                        isFastDropping = true;
                        dropCounter = dropInterval; // Force immediate drop on first press
                    }
                    e.preventDefault();
                    break;
                case 'arrowup':
                case 'w':
                case ' ': 
                    attemptRotate();
                    e.preventDefault();
                    break;
                case 'p': 
                    pauseGame();
                    e.preventDefault();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'arrowdown' || e.key.toLowerCase() === 's') {
                isFastDropping = false;
                e.preventDefault();
            }
        });


        startButton.addEventListener('click', () => {
            startGame();
        });
        pauseButton.addEventListener('click', () => {
            pauseGame();
        });
        
        // Touch controls (D-pad and Action buttons)
        document.getElementById('d-pad-left').addEventListener('click', () => movePiece(-1, 0));
        document.getElementById('d-pad-right').addEventListener('click', () => movePiece(1, 0));
        
        // D-pad down for accelerated drop
        dPadDown.addEventListener('mousedown', () => { isFastDropping = true; dropCounter = dropInterval; });
        dPadDown.addEventListener('mouseup', () => { isFastDropping = false; });
        dPadDown.addEventListener('mouseleave', () => { isFastDropping = false; }); // Stop if finger slides off
        dPadDown.addEventListener('touchstart', (e) => { isFastDropping = true; dropCounter = dropInterval; e.preventDefault(); });
        dPadDown.addEventListener('touchend', (e) => { isFastDropping = false; e.preventDefault(); });


        document.getElementById('d-pad-up').addEventListener('click', () => attemptRotate()); 
        document.getElementById('action-a').addEventListener('click', () => attemptRotate()); 
        document.getElementById('action-b').addEventListener('click', () => attemptRotate()); // B button for rotate


        // Initialization
        function initGame() {
            canvas.width = COLS * BLOCK_SIZE;
            canvas.height = ROWS * BLOCK_SIZE;
            nextCanvas.width = NEXT_COLS * BLOCK_SIZE * 0.8; 
            nextCanvas.height = NEXT_ROWS * BLOCK_SIZE * 0.8;
            
            context.scale(1, 1); 
            nextContext.scale(1, 1);

            showMessage('Press START or<br>ENTER to Play!', 0, true);
            pauseButton.disabled = true; 
            
            board = createBoard();
            drawBoard();
            nextContext.fillStyle = COLORS.BACKGROUND;
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
        }

        window.addEventListener('resize', () => {}); // Basic handler, no complex resizing needed for fixed game size

        initGame();

    </script>
</body>
</html>