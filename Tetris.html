<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Boy Tetris</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            background-color: #d3d3d3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            color: #0F380F;
            overflow: hidden;
        }

        #gameboy-shell {
            background-color: #8c8c8c;
            padding: 20px;
            border-radius: 10px 10px 50px 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3), inset 0 0 10px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #screen-bezel {
            background-color: #777;
            padding: 15px;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }

        #gameboy-screen {
            background-color: #9BBC0F;
            padding: 10px;
            border: 2px solid #0F380F;
            border-radius: 5px;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
            width: calc(200px + 120px + 20px); 
            height: calc(360px + 20px + 50px + 40px); 
            overflow: hidden; 
            position: relative; 
        }

        #game-container {
            display: flex;
            align-items: flex-start; 
            width: 100%; 
        }
        #game-container.hidden {
            display: none !important;
        }


        #tetris-board {
            border: 2px solid #0F380F; 
            background-color: #9BBC0F; 
        }

        #game-info {
            width: 120px; 
            padding-left: 15px;
            font-size: 10px; 
            line-height: 1.4; 
            color: #0F380F; 
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            height: 100%;
        }

        #game-info div { margin-bottom: 5px; } 
        #game-info span { display: block; text-align: right; padding-right: 5px; }
        #next-piece-container { margin-top: 8px; } 
        #next-piece-canvas {
            border: 1px solid #306230; 
            background-color: #8BAC0F; 
            display: block;
            margin-top: 3px; 
        }
        
        #title-header {
            font-size: 16px;
            color: #0F380F;
            margin-bottom: 5px;
            text-align: center;
        }

        #controls {
            margin-top: 10px; 
            display: flex;
            gap: 5px; 
            flex-wrap: wrap; 
            justify-content: center;
        }

        #controls button, .action-button {
            font-family: 'Press Start 2P', cursive;
            background-color: #555; 
            color: #ddd; 
            border: 2px solid #333;
            padding: 8px 10px; 
            border-radius: 5px;
            box-shadow: 0 2px 0 #333, 0 4px 5px rgba(0,0,0,0.3);
            cursor: pointer;
            font-size: 10px; 
            transition: all 0.1s ease;
            text-transform: uppercase;
        }

        #controls button:active, .action-button:active {
            background-color: #444;
            box-shadow: 0 1px 0 #333;
            transform: translateY(1px);
        }
        
        #message-box {
            position: absolute; 
            top: 40%; 
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(15, 56, 15, 0.9); 
            color: #9BBC0F; 
            padding: 15px; 
            border: 3px solid #306230; 
            border-radius: 5px;
            font-size: 13px; 
            line-height: 1.4;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            width: 85%; 
        }
        #bottom-message-box {
            position: absolute;
            bottom: 5px; 
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(15, 56, 15, 0.85);
            color: #9BBC0F;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 10px;
            text-align: center;
            z-index: 99; 
            width: 90%;
        }


        .hidden { display: none !important; }

        #gameboy-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 300px; 
            margin-top: 20px;
        }

        #d-pad {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-template-rows: repeat(3, 40px);
            gap: 2px;
        }

        .d-pad-btn {
            background-color: #333; 
            border: 1px solid #222;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9BBC0F;
            font-size: 18px;
            cursor: pointer;
            user-select: none; 
        }
        .d-pad-btn:active { background-color: #222; }
        #d-pad-up { grid-column: 2; grid-row: 1; }
        #d-pad-left { grid-column: 1; grid-row: 2; }
        #d-pad-center { grid-column: 2; grid-row: 2; background-color: #444; } 
        #d-pad-right { grid-column: 3; grid-row: 2; }
        #d-pad-down { grid-column: 2; grid-row: 3; }

        #action-buttons { display: flex; flex-direction: column; gap: 10px; }
        .action-button { 
            width: 60px; height: 60px; border-radius: 50%; 
            background-color: #a04050; color: #fff;
            font-size: 20px; line-height: 56px; 
            text-align: center; user-select: none; 
        }
        .action-button.b { background-color: #903040; }
        
        #high-scores {
            width: 100%; height: 100%; display: flex;
            flex-direction: column; align-items: center;
            justify-content: flex-start; padding-top: 10px; 
            box-sizing: border-box;
        }
        #high-scores h2 { font-size: 16px; margin-bottom: 8px; }
        #high-scores-content {
            font-size: 9px; 
            line-height: 1.3;
            max-height: 250px; 
            overflow-y: auto;
            width: 95%;
            text-align: left;
            padding: 5px;
            border: 1px solid #306230;
            background-color: #8BAC0F;
        }
        #high-scores-content table {
            width: 100%;
            border-collapse: collapse;
        }
        #high-scores-content th, #high-scores-content td {
            padding: 1px 2px; 
            border: 1px dotted rgba(15, 56, 15, 0.3);
            text-align: center; 
        }
        #high-scores-content th.name-col, #high-scores-content td.name-col {
            text-align: left; 
            width: 30%; 
        }
         #high-scores-content th.date-col, #high-scores-content td.date-col {
            width: 20%; 
        }
        #high-scores-content th {
            background-color: rgba(15, 56, 15, 0.1); 
        }

        #high-score-instructions {
            margin-top: 10px; font-size: 11px; text-align: center; line-height: 1.5;
        }
        #high-score-instructions div { margin-bottom: 3px; }

        @media (max-width: 600px) {
            #gameboy-shell { padding: 10px; transform: scale(0.9); }
            #screen-bezel { padding: 10px; }
            #gameboy-screen {
                width: calc(100vw - 60px); 
                max-width: calc(200px + 120px + 20px); 
                height: calc(360px + 20px + 70px + 40px); 
            }
            #game-container { flex-direction: column; align-items: center; }
            #game-info { width: 100%; padding-left: 0; margin-top: 10px; text-align: center; }
            #game-info span { text-align: center; }
            #next-piece-container { margin: 10px auto; }
            #next-piece-canvas { margin: 5px auto; }
            #gameboy-controls { flex-direction: column; gap: 15px; width: 100%; }
            #controls { order: 2; }
            #d-pad { order: 1; }
            #action-buttons { order: 0; flex-direction: row; }
        }
    </style>
</head>
<body>
    <div id="gameboy-shell">
        <div id="screen-bezel">
            <div id="title-header">TETRIS</div>
            <div id="gameboy-screen">
                <div id="game-container">
                    <canvas id="tetris-board"></canvas>
                    <div id="game-info">
                        <div>SCORE<span id="score">0</span></div>
                        <div>LEVEL<span id="level">0</span></div>
                        <div>LINES<span id="lines-cleared">0</span></div>
                        <div id="next-piece-container">
                            NEXT:
                            <canvas id="next-piece-canvas"></canvas>
                        </div>
                        <hr style="border-color: #306230; margin: 5px 0;">
                        <div>SINGLE<span id="info-singles">0</span></div>
                        <div>DOUBLE<span id="info-doubles">0</span></div>
                        <div>TRIPLE<span id="info-triples">0</span></div>
                        <div>TETRIS<span id="info-tetrises">0</span></div>
                    </div>
                </div>
                <div id="high-scores" class="hidden">
                    <h2>High Scores</h2>
                    <div id="high-scores-content"></div>
                    <div id="high-score-instructions">
                        <div>◀ Left: Prev Cat.</div>
                        <div>▶ Right: Next Cat.</div>
                        <div>'B' Key: Close</div>
                    </div>
                </div>
                 <div id="message-box" class="hidden"></div>
                 <div id="bottom-message-box" class="hidden"></div>
            </div>
        </div>
       
        <div id="controls">
            <button id="start-button">START</button>
            <button id="pause-button">PAUSE</button>
            <button id="high-scores-button">SCORES</button>
            <button id="mute-button">MUSIC: ON</button>
        </div>
        <div id="gameboy-controls">
            <div id="d-pad">
                <button class="d-pad-btn" id="d-pad-up" title="Rotate">▲</button>
                <button class="d-pad-btn" id="d-pad-left" title="Move Left / Prev Category">◀</button>
                <div class="d-pad-btn" id="d-pad-center"></div>
                <button class="d-pad-btn" id="d-pad-right" title="Move Right / Next Category">▶</button>
                <button class="d-pad-btn" id="d-pad-down" title="Move Down">▼</button>
            </div>
            <div id="action-buttons">
                <button class="action-button b" id="action-b" title="Rotate Clockwise (B) / Close Scores">B</button>
                <button class="action-button a" id="action-a" title="Rotate Counter-Clockwise (A)">A</button>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements (mostly unchanged)
        const canvas = document.getElementById('tetris-board');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-piece-canvas');
        const nextContext = nextCanvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const linesClearedElement = document.getElementById('lines-cleared');
        const messageBox = document.getElementById('message-box');
        const bottomMessageBox = document.getElementById('bottom-message-box');
        const startButton = document.getElementById('start-button');
        const pauseButton = document.getElementById('pause-button');
        const muteButton = document.getElementById('mute-button');
        const infoSinglesElement = document.getElementById('info-singles');
        const infoDoublesElement = document.getElementById('info-doubles');
        const infoTriplesElement = document.getElementById('info-triples');
        const infoTetrisesElement = document.getElementById('info-tetrises');
        const gameContainer = document.getElementById('game-container');
        const highScoresDiv = document.getElementById('high-scores');
        const highScoresContent = document.getElementById('high-scores-content');
        const dPadUp = document.getElementById('d-pad-up');
        const dPadLeft = document.getElementById('d-pad-left');
        const dPadRight = document.getElementById('d-pad-right');
        const dPadDown = document.getElementById('d-pad-down');
        const actionA = document.getElementById('action-a');
        const actionB = document.getElementById('action-b');

        // Game constants & state (mostly unchanged)
        const COLS = 10; const ROWS = 18; const BLOCK_SIZE = 20; 
        const NEXT_COLS = 4; const NEXT_ROWS = 4;
        const FAST_DROP_INTERVAL = 2; const INITIAL_BPM = 120; const BPM_INCREMENT_PER_LEVEL = 10; 
        const COLORS = { BACKGROUND: '#9BBC0F', GRID_LINES: '#8BAC0F', BLOCK: '#0F380F', TEXT: '#0F380F', PIECE_SHADOW: '#306230' };
        const TETROMINOES = { /* ... */ 
            'I': { shape: [[1,1,1,1]], color: COLORS.BLOCK, x: 0, y: 0 }, 'J': { shape: [[1,0,0], [1,1,1]], color: COLORS.BLOCK, x: 0, y: 0 },
            'L': { shape: [[0,0,1], [1,1,1]], color: COLORS.BLOCK, x: 0, y: 0 }, 'O': { shape: [[1,1], [1,1]], color: COLORS.BLOCK, x: 1, y: 1 },
            'S': { shape: [[0,1,1], [1,1,0]], color: COLORS.BLOCK, x: 0, y: 1 }, 'T': { shape: [[0,1,0], [1,1,1]], color: COLORS.BLOCK, x: 0, y: 1 },
            'Z': { shape: [[1,1,0], [0,1,1]], color: COLORS.BLOCK, x: 0, y: 1 }
        };
        const PIECE_KEYS = Object.keys(TETROMINOES);
        let board, currentPiece, nextPiece, score, level, linesCleared;
        let singleLines, doubleLines, tripleLines, tetrisLines;
        let dropCounter, dropInterval, gameOver, paused, gameLoopId;
        let audioInitialized = false, isFastDropping = false, isHighScoreScreenActive = false;
        let isNameEntryActive = false; let isMusicMuted = false;

        // Sound (Tone.js) - melody and init/play functions remain largely the same
        let moveSound, rotateSound, landSound, lineClearSound, tetrisSound, gameOverSound, levelUpSound;
        let themeMusicSynth, themeMusicSequence;
        const tetrisMelody = [ /* ... melody data ... */ 
            { time: '0:0:0', note: 'E5', duration: '4n' }, { time: '0:1:0', note: 'B4', duration: '8n' }, { time: '0:1:2', note: 'C5', duration: '8n' },
            { time: '0:2:0', note: 'D5', duration: '4n' }, { time: '0:3:0', note: 'C5', duration: '8n' }, { time: '0:3:2', note: 'B4', duration: '8n' },
            { time: '0:4:0', note: 'A4', duration: '4n' }, { time: '0:5:0', note: 'A4', duration: '8n' }, { time: '0:5:2', note: 'C5', duration: '8n' },
            { time: '0:6:0', note: 'E5', duration: '4n' }, { time: '0:7:0', note: 'D5', duration: '8n' }, { time: '0:7:2', note: 'C5', duration: '8n' },
            { time: '1:0:0', note: 'B4', duration: '2n' }, { time: '1:2:0', note: 'C5', duration: '4n' },
            { time: '1:3:0', note: 'D5', duration: '2n' }, { time: '1:5:0', note: 'E5', duration: '2n' },
            { time: '2:0:0', note: 'C5', duration: '2n' }, { time: '2:2:0', note: 'A4', duration: '2n' },
            { time: '2:4:0', note: 'A4', duration: '1n' }, 
            { time: '3:0:0', note: 'D5', duration: '4n.' }, { time: '3:1:2', note: 'F5', duration: '8n' }, { time: '3:2:0', note: 'A5', duration: '2n' },
            { time: '3:4:0', note: 'G5', duration: '8n' }, { time: '3:4:2', note: 'F5', duration: '8n' }, { time: '3:5:0', note: 'E5', duration: '2n.' }, 
            { time: '4:0:0', note: 'C5', duration: '4n.' }, { time: '4:1:2', note: 'E5', duration: '8n' }, { time: '4:2:0', note: 'D5', duration: '8n' }, { time: '4:2:2', note: 'C5', duration: '8n' },
            { time: '4:3:0', note: 'B4', duration: '2n' }, { time: '4:5:0', note: 'C5', duration: '4n' },
            { time: '4:6:0', note: 'D5', duration: '2n' }, { time: '5:0:0', note: 'E5', duration: '2n' },
            { time: '5:2:0', note: 'C5', duration: '2n' }, { time: '5:4:0', note: 'A4', duration: '2n' },
            { time: '6:0:0', note: 'A4', duration: '1n' }
        ];
        function initSounds() { /* ... unchanged ... */ 
            if (audioInitialized) return;
            try {
                moveSound = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
                rotateSound = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
                landSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                lineClearSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
                tetrisSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "pulse", width: 0.3 }, envelope: { attack: 0.01, decay: 0.4, sustain: 0.2, release: 0.3 } }).toDestination();
                gameOverSound = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.1, decay: 0.5, sustain: 0, release: 0.5 } }).toDestination();
                levelUpSound = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.05, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination();

                themeMusicSynth = new Tone.Synth({
                    oscillator: { type: 'pulse', width: 0.4 }, 
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.1 }
                }).toDestination();
                themeMusicSynth.volume.value = -12; 

                themeMusicSequence = new Tone.Sequence((time, noteEvent) => {
                    if (isMusicMuted) return;
                    themeMusicSynth.triggerAttackRelease(noteEvent.note, noteEvent.duration, time);
                }, tetrisMelody, "4n"); 
                themeMusicSequence.loop = true;
                Tone.Transport.bpm.value = INITIAL_BPM;

                audioInitialized = true;
            } catch (e) { console.error("Failed to initialize audio:", e); audioInitialized = false;  }
        }
        function playSound(sound, note, duration = "16n", time = "+0") { /* ... unchanged ... */ 
            if (audioInitialized && sound && Tone.context.state === 'running') {
                if (sound instanceof Tone.PolySynth) {
                    sound.triggerAttackRelease(note, duration, Tone.now() + parseFloat(time));
                } else {
                    sound.triggerAttackRelease(note, duration, Tone.now() + parseFloat(time));
                }
            }
        }

        // Game Logic 
        function createBoard() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }
        function getRandomPiece() { /* ... unchanged ... */ 
            const randIndex = Math.floor(Math.random() * PIECE_KEYS.length);
            const key = PIECE_KEYS[randIndex];
            const pieceData = TETROMINOES[key];
            const shape = pieceData.shape.map(row => row.slice()); 
            return { shape, color: pieceData.color, x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2), y: 0 };
        }
        function rotate(piece) { /* ... unchanged ... */ 
            const N = piece.shape.length;
            const M = piece.shape[0].length;
            const newShape = Array.from({ length: M }, () => Array(N).fill(0));
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < M; c++) {
                    if (piece.shape[r][c]) newShape[c][N - 1 - r] = piece.shape[r][c];
                }
            }
            piece.shape = newShape;
        }
        function rotateCounterClockwise(piece) { /* ... unchanged ... */ 
            const N = piece.shape.length;
            const M = piece.shape[0].length;
            const newShape = Array.from({ length: M }, () => Array(N).fill(0));
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < M; c++) {
                    if (piece.shape[r][c]) newShape[M - 1 - c][r] = piece.shape[r][c];
                }
            }
            piece.shape = newShape;
        }
        function checkCollision(piece, board, offsetX = 0, offsetY = 0) { /* ... unchanged ... */
            const { shape, x: pieceX, y: pieceY } = piece;
            const finalX = pieceX + offsetX;
            const finalY = pieceY + offsetY;
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c]) {
                        const boardX = finalX + c;
                        const boardY = finalY + r;
                        if (boardX < 0 || boardX >= COLS || boardY >= ROWS || (boardY >= 0 && board[boardY] && board[boardY][boardX])) return true;
                    }
                }
            }
            return false;
         }
        function lockPiece() { /* ... unchanged ... */
            currentPiece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) {
                        const boardX = currentPiece.x + c;
                        const boardY = currentPiece.y + r;
                        if (boardY >= 0 && boardY < ROWS && boardX >=0 && boardX < COLS) board[boardY][boardX] = currentPiece.color;
                    }
                });
            });
            if (audioInitialized) playSound(landSound, "C3");
         }
        function clearLines() { /* ... unchanged, already fixed in previous response ... */ 
            let linesClearedThisTurn = 0;
            for (let r = ROWS - 1; r >= 0; ) {
                if (board[r].every(cell => cell !== 0)) {
                    linesClearedThisTurn++; linesCleared++; 
                    board.splice(r, 1); board.unshift(Array(COLS).fill(0)); 
                } else { r--; }
            }
            if (linesClearedThisTurn > 0) {
                updateScore(linesClearedThisTurn); updateLevel();
                if (linesClearedThisTurn === 1) { singleLines++; infoSinglesElement.textContent = singleLines; } 
                else if (linesClearedThisTurn === 2) { doubleLines++; infoDoublesElement.textContent = doubleLines; } 
                else if (linesClearedThisTurn === 3) { tripleLines++; infoTriplesElement.textContent = tripleLines; } 
                else if (linesClearedThisTurn === 4) { tetrisLines++; infoTetrisesElement.textContent = tetrisLines; }
                if (audioInitialized) {
                    if (linesClearedThisTurn === 4) playSound(tetrisSound, ["C4", "E4", "G4", "C5"], "2n");
                    else playSound(lineClearSound, ["C5", "E5", "G5"], "8n");
                }
            }
        }
        function updateScore(clearedCount) { /* ... unchanged ... */ 
            const points = [0, 40, 100, 300, 1200]; 
            score += points[clearedCount] * (level + 1);
            scoreElement.textContent = score;
        }
        function updateLevel() { /* ... unchanged ... */ 
            const newLevel = Math.floor(linesCleared / 10); 
            if (newLevel > level) {
                level = newLevel; levelElement.textContent = level;
                const levelSpeeds = [48, 43, 38, 33, 28, 23, 18, 13, 8, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1];
                dropInterval = levelSpeeds[Math.min(level, levelSpeeds.length - 1)] || 1;
                if (audioInitialized && Tone.context.state === 'running') {
                    if (!isMusicMuted) Tone.Transport.bpm.value = INITIAL_BPM + (level * BPM_INCREMENT_PER_LEVEL);
                    playSound(levelUpSound, "A4", "4n");
                }
                showMessage(`LEVEL ${level + 1}!`, 1000);
            }
            linesClearedElement.textContent = linesCleared;
        }

        // Drawing (drawBlock, drawBoard, drawPiece, drawNextPiece) - mostly unchanged
        function drawBlock(x, y, color, ctx = context, bs = BLOCK_SIZE) { /* ... */ 
            ctx.fillStyle = color; ctx.fillRect(x * bs, y * bs, bs, bs);
            ctx.fillStyle = COLORS.PIECE_SHADOW; 
            ctx.fillRect(x * bs + bs - 2, y * bs, 2, bs); ctx.fillRect(x * bs, y * bs + bs - 2, bs, 2); 
            ctx.strokeStyle = COLORS.GRID_LINES; ctx.strokeRect(x * bs, y * bs, bs, bs);
        }
        function drawBoard() { /* ... */
            context.fillStyle = COLORS.BACKGROUND; context.fillRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) drawBlock(c, r, board[r][c]);
                    else { context.strokeStyle = 'rgba(15, 56, 15, 0.1)'; context.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); }
                }
            }
         }
        function drawPiece(piece, ctx = context, bs = BLOCK_SIZE, offX = 0, offY = 0) { /* ... */ 
            piece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) drawBlock(piece.x + c + offX, piece.y + r + offY, piece.color, ctx, bs);
                });
            });
        }
        function drawNextPiece() { /* ... */ 
            nextContext.fillStyle = COLORS.BACKGROUND; nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (nextPiece) {
                let pieceKeyForNext = PIECE_KEYS.find(k => JSON.stringify(TETROMINOES[k].shape) === JSON.stringify(nextPiece.shape));
                const pieceDetails = pieceKeyForNext ? TETROMINOES[pieceKeyForNext] : {x:0, y:0}; 
                const shapeWidth = nextPiece.shape[0].length; const shapeHeight = nextPiece.shape.length;
                const offsetX = Math.floor((NEXT_COLS - shapeWidth) / 2) - (pieceDetails.x || 0);
                const offsetY = Math.floor((NEXT_ROWS - shapeHeight) / 2) - (pieceDetails.y || 0);
                const tempPiece = { shape: nextPiece.shape, color: nextPiece.color, x: offsetX, y: offsetY };
                drawPiece(tempPiece, nextContext, BLOCK_SIZE * 0.8, 0, 0); 
            }
        }
        
        function gameLoop() { /* ... unchanged ... */
            if (gameOver || paused) { if (gameLoopId) cancelAnimationFrame(gameLoopId); return; }
            let currentDropIntervalForLoop = isFastDropping ? FAST_DROP_INTERVAL : dropInterval;
            dropCounter++;
            if (dropCounter >= currentDropIntervalForLoop) { movePiece(0, 1); dropCounter = 0; }
            drawBoard(); drawPiece(currentPiece);
            gameLoopId = requestAnimationFrame(gameLoop);
         }
        let horizontalMoveTimeout; 
        function movePiece(dx, dy) { /* ... game over logic here is key, unchanged ... */ 
            if (gameOver || paused) return;
            if (dx !== 0 && horizontalMoveTimeout) return;
            if (!checkCollision(currentPiece, board, dx, dy)) {
                currentPiece.x += dx; currentPiece.y += dy;
                if (dy > 0) dropCounter = 0;
                if (dx !== 0 && audioInitialized) playSound(moveSound, "C4", "32n");
            } else if (dy > 0) { 
                lockPiece(); clearLines(); 
                currentPiece = nextPiece; nextPiece = getRandomPiece();
                currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2); currentPiece.y = 0; 
                drawNextPiece(); 
                if (checkCollision(currentPiece, board)) { drawBoard(); drawPiece(currentPiece); endGame(); return; }
            }
            if (dx !== 0) horizontalMoveTimeout = setTimeout(() => { horizontalMoveTimeout = null; }, 80); 
        }
        let rotateTimeout; 
        function attemptRotate(direction = 1) { /* ... unchanged ... */ 
            if (gameOver || paused) return; if (rotateTimeout) return;
            const originalShape = currentPiece.shape.map(row => row.slice());
            const originalX = currentPiece.x; const originalY = currentPiece.y;
            if (direction === 1) rotate(currentPiece); else rotateCounterClockwise(currentPiece);
            if (audioInitialized) playSound(rotateSound, "E4", "16n");
            let offset = 0;
            if (checkCollision(currentPiece, board)) { 
                offset = currentPiece.x < COLS / 2 ? 1 : -1; 
                if (!checkCollision(currentPiece, board, offset, 0)) currentPiece.x += offset;
                else if (!checkCollision(currentPiece, board, -offset, 0)) currentPiece.x -= offset;
                else if (!checkCollision(currentPiece, board, offset * 2, 0)) currentPiece.x += offset * 2;
                else if (!checkCollision(currentPiece, board, -offset * 2, 0)) currentPiece.x -= offset * 2;
                else { currentPiece.shape = originalShape; currentPiece.x = originalX; currentPiece.y = originalY; }
            }
            rotateTimeout = setTimeout(() => { rotateTimeout = null; }, 150);
        }

        async function startGame() { /* ... Initialization of line type display added in previous response ... */
            if (isNameEntryActive) return; 
            if (!audioInitialized) { /* ... audio init ... */ 
                try { await Tone.start(); initSounds(); console.log("Audio context started."); } 
                catch (e) { console.warn("Audio context not started:", e); }
            } else if (Tone.context.state !== 'running') {
                 try { await Tone.start(); console.log("Audio context re-started."); } 
                 catch (e) { console.warn("Audio context could not be re-started:", e); }
            }

            board = createBoard(); currentPiece = getRandomPiece();
            currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2); currentPiece.y = 0;
            if (checkCollision(currentPiece, board)) { drawBoard(); drawPiece(currentPiece); endGame(); return; }
            nextPiece = getRandomPiece(); drawNextPiece();
            score = 0; level = 0; linesCleared = 0;
            singleLines = 0; doubleLines = 0; tripleLines = 0; tetrisLines = 0; 
            dropCounter = 0; dropInterval = 48; 
            gameOver = false; paused = false; isFastDropping = false;
            isHighScoreScreenActive = false; isNameEntryActive = false;
            scoreElement.textContent = score; levelElement.textContent = level; linesClearedElement.textContent = linesCleared;
            infoSinglesElement.textContent = singleLines; infoDoublesElement.textContent = doubleLines;
            infoTriplesElement.textContent = tripleLines; infoTetrisesElement.textContent = tetrisLines;
            hideMessage(); hideBottomMessage();
            highScoresDiv.classList.add('hidden'); gameContainer.classList.remove('hidden'); 
            startButton.textContent = "END GAME";
            pauseButton.textContent = "PAUSE"; pauseButton.disabled = false;
            if (audioInitialized && Tone.context.state === 'running' && !isMusicMuted) {
                Tone.Transport.bpm.value = INITIAL_BPM + (level * BPM_INCREMENT_PER_LEVEL);
                if (themeMusicSequence && themeMusicSequence.state !== "started") themeMusicSequence.start(0);
                if (Tone.Transport.state !== "started") Tone.Transport.start();
            }
            if (gameLoopId) cancelAnimationFrame(gameLoopId); 
            gameLoop();
        }

        function pauseGame() {
            if (gameOver || isNameEntryActive) return;
            paused = !paused;
            if (paused) {
                if (gameLoopId) cancelAnimationFrame(gameLoopId);
                showMessage('PAUSED', 0, true); pauseButton.textContent = "RESUME";
                if (audioInitialized && Tone.Transport.state === "started") Tone.Transport.pause();
            } else {
                showMessage('RESUMED', 800); pauseButton.textContent = "PAUSE";
                if (audioInitialized && Tone.Transport.state === "paused" && !isMusicMuted) Tone.Transport.start();
                gameLoop(); 
            }
        }
        
        function isScoreWorthy(currentScore, currentLevel, currentLines, currentStats) {
            // Basic check: if score is 0 and no lines cleared, it's not worthy.
            if (currentScore === 0 && currentLines === 0 && currentLevel === 0) {
                // Further check if any specific line counts are also 0
                if ((currentStats.singles || 0) === 0 &&
                    (currentStats.doubles || 0) === 0 &&
                    (currentStats.triples || 0) === 0 &&
                    (currentStats.tetrises || 0) === 0) {
                    return false;
                }
            }

            // Check against existing high scores for each category
            // If any list is not full (less than 10 scores), any non-zero score is worthy for that list.
            // If a list is full, the new score must be higher than the lowest score on that list.
            for (const category of highScoreCategories) {
                const categoryScores = highScores[category] || [];
                let valueForCategory;
                switch (category) {
                    case "Most Points": valueForCategory = currentScore; break;
                    case "Highest Level": valueForCategory = currentLevel; break;
                    case "Most Tetrises": valueForCategory = currentStats.tetrises || 0; break;
                    case "Most Triple Lines": valueForCategory = currentStats.triples || 0; break;
                    case "Most Double Lines": valueForCategory = currentStats.doubles || 0; break;
                    case "Most Single Lines": valueForCategory = currentStats.singles || 0; break;
                    default: valueForCategory = 0;
                }

                if (valueForCategory > 0) { // Only consider if there's a positive value for the category
                    if (categoryScores.length < 10) return true; // List not full, worthy
                    // Sort scores to find the lowest (last element after sorting descending)
                    const sortedCategoryScores = [...categoryScores].sort((a, b) => (b.value || 0) - (a.value || 0));
                    if (valueForCategory > (sortedCategoryScores[9]?.value || 0)) return true; // Higher than lowest, worthy
                }
            }
            return false; // Not worthy for any category
        }


        function endGame() {
            if (gameOver) return; gameOver = true;
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            if (audioInitialized) {
                playSound(gameOverSound, "G2", "1n");
                if (themeMusicSequence && themeMusicSequence.state !== "stopped") themeMusicSequence.stop(0);
                if (Tone.Transport.state !== "stopped") Tone.Transport.stop(0);
            }
            startButton.textContent = "START";
            pauseButton.textContent = "PAUSE"; pauseButton.disabled = true;
            isFastDropping = false;
            
            const currentStats = { 
                level, points: score, lines: linesCleared, 
                singles: singleLines, doubles: doubleLines, triples: tripleLines, tetrises: tetrisLines 
            };

            if (isScoreWorthy(score, level, linesCleared, currentStats)) {
                isNameEntryActive = true; 
                enterName((name) => {
                    isNameEntryActive = false; 
                    if (name) { 
                        addHighScore("Most Points", name, score, currentStats);
                        addHighScore("Highest Level", name, level, currentStats);
                        addHighScore("Most Tetrises", name, tetrisLines, currentStats);
                        addHighScore("Most Triple Lines", name, tripleLines, currentStats);
                        addHighScore("Most Double Lines", name, doubleLines, currentStats);
                        addHighScore("Most Single Lines", name, singleLines, currentStats);
                        showMessage(`Score for ${name} Saved!`, 2500);
                    } else { showMessage("Name entry skipped.", 2000); }
                    setTimeout(() => {
                        if (gameOver && !isNameEntryActive) { 
                             showBottomMessage("Press START or ENTER to Play!"); hideMessage();
                        }
                    }, name ? 2600 : 2100); 
                });
            } else {
                // Score not worthy, just show game over and prompt to play again
                showMessage("GAME OVER!", 2000);
                 setTimeout(() => {
                    if (gameOver && !isNameEntryActive) { 
                         showBottomMessage("Press START or ENTER to Play!"); hideMessage();
                    }
                }, 2100);
            }
        }

        function showMessage(text, duration = 2000, persistent = false) { /* ... */ 
            messageBox.innerHTML = text; messageBox.classList.remove('hidden');
            if (!persistent && duration > 0) {
                setTimeout(() => {
                    if (messageBox.innerHTML === text && !isNameEntryActive && !paused && !gameOver && !text.startsWith("GAME OVER!")) {
                         messageBox.classList.add('hidden');
                    } else if (messageBox.innerHTML === text && (text.startsWith("Score for") || text.startsWith("Name entry skipped") || text.startsWith("GAME OVER!"))) {
                         messageBox.classList.add('hidden');
                    }
                }, duration);
            }
        }
        function hideMessage() { messageBox.classList.add('hidden'); }
        function showBottomMessage(text) { bottomMessageBox.innerHTML = text; bottomMessageBox.classList.remove('hidden'); }
        function hideBottomMessage() { bottomMessageBox.classList.add('hidden'); }
        
        document.addEventListener('keydown', (e) => {
            if (isNameEntryActive) return; 
            if (isHighScoreScreenActive) { handleHighScoreKeys(e); return; }
            if (gameOver && e.key.toLowerCase() !== 'enter' && !isNameEntryActive) return; 
            if (!currentPiece && e.key.toLowerCase() !== 'enter' && !gameOver && !paused && !isNameEntryActive) return; 
            if (e.key.toLowerCase() === 'enter') {
                if (gameOver || (!gameLoopId && !paused && !isHighScoreScreenActive && !isNameEntryActive)) { startGame(); e.preventDefault(); return; }
            }
            if (paused && e.key.toLowerCase() !== 'p') return; 
            switch (e.key.toLowerCase()) { 
                case 'arrowleft': movePiece(-1, 0); e.preventDefault(); break;
                case 'arrowright': movePiece(1, 0); e.preventDefault(); break;
                case 'arrowdown':
                    if (!isFastDropping) { isFastDropping = true; dropCounter = dropInterval; }
                    movePiece(0, 1); e.preventDefault(); break;
                case 'arrowup': attemptRotate(1); e.preventDefault(); break;
                case 'a': attemptRotate(-1); e.preventDefault(); break;
                case 'b': case ' ': attemptRotate(1); e.preventDefault(); break;
                case 'p': pauseGame(); e.preventDefault(); break;
                case 'm': toggleMusicMute(); e.preventDefault(); break; 
            }
        });

        document.addEventListener('keyup', (e) => {
            if (isNameEntryActive || isHighScoreScreenActive) return;
            if (e.key.toLowerCase() === 'arrowdown') { isFastDropping = false; e.preventDefault(); }
        });

        startButton.addEventListener('click', () => {
            if (isNameEntryActive) return; 
            if (isHighScoreScreenActive) closeHighScores();
            if (startButton.textContent === "START") startGame();
            else if (startButton.textContent === "END GAME") endGame(); 
        });
        pauseButton.addEventListener('click', pauseGame);
        muteButton.addEventListener('click', toggleMusicMute);

        function toggleMusicMute() { /* ... unchanged ... */ 
            isMusicMuted = !isMusicMuted;
            muteButton.textContent = isMusicMuted ? "MUSIC: OFF" : "MUSIC: ON";
            if (audioInitialized && Tone.context.state === 'running') {
                if (isMusicMuted) {
                    if (themeMusicSequence && themeMusicSequence.state === "started") themeMusicSequence.stop(0); 
                    if (Tone.Transport.state === "started") Tone.Transport.pause(); 
                } else {
                    if (!gameOver && !paused && gameLoopId) {
                        Tone.Transport.bpm.value = INITIAL_BPM + (level * BPM_INCREMENT_PER_LEVEL);
                        if (themeMusicSequence && themeMusicSequence.state !== "started") themeMusicSequence.start(0);
                        if (Tone.Transport.state !== "started") Tone.Transport.start();
                    }
                }
            }
        }
        
        // D-Pad and Action Button Listeners with dual functionality
        dPadLeft.addEventListener('click', () => {
            if (isHighScoreScreenActive) handleHighScoreKeyPress('arrowleft');
            else if (!isNameEntryActive) movePiece(-1, 0);
        });
        dPadRight.addEventListener('click', () => {
            if (isHighScoreScreenActive) handleHighScoreKeyPress('arrowright');
            else if (!isNameEntryActive) movePiece(1, 0);
        });
        actionB.addEventListener('click', () => {
            if (isHighScoreScreenActive) handleHighScoreKeyPress('b');
            else if (!isNameEntryActive) attemptRotate(1);
        });
        dPadUp.addEventListener('click', () => { if (!isHighScoreScreenActive && !isNameEntryActive) attemptRotate(1); });
        actionA.addEventListener('click', () => { if (!isHighScoreScreenActive && !isNameEntryActive) attemptRotate(-1); });
        dPadDown.addEventListener('mousedown', () => { if(!paused && !gameOver && !isHighScoreScreenActive && !isNameEntryActive) {isFastDropping = true; dropCounter = dropInterval;} });
        dPadDown.addEventListener('mouseup', () => { if(!paused && !gameOver && !isHighScoreScreenActive && !isNameEntryActive) isFastDropping = false; });
        dPadDown.addEventListener('mouseleave', () => { if(!paused && !gameOver && !isHighScoreScreenActive && !isNameEntryActive) isFastDropping = false; });
        dPadDown.addEventListener('touchstart', (e) => { if(!paused && !gameOver && !isHighScoreScreenActive && !isNameEntryActive) {isFastDropping = true; dropCounter = dropInterval;} e.preventDefault(); });
        dPadDown.addEventListener('touchend', (e) => { if(!paused && !gameOver && !isHighScoreScreenActive && !isNameEntryActive) isFastDropping = false; e.preventDefault(); });


        // High Score Logic
        const highScoreCategories = ["Most Points", "Highest Level", "Most Tetrises", "Most Triple Lines", "Most Double Lines", "Most Single Lines"];
        let currentCategoryIndex = 0;
        let highScores = JSON.parse(localStorage.getItem("tetrisHighScores")) || highScoreCategories.reduce((acc, cat) => { acc[cat] = []; return acc; }, {});
        function saveHighScores() { localStorage.setItem("tetrisHighScores", JSON.stringify(highScores)); }

        function displayHighScores() {
            isHighScoreScreenActive = true;
            gameContainer.classList.add("hidden");
            highScoresDiv.classList.remove("hidden");
            hideMessage(); hideBottomMessage(); 

            const category = highScoreCategories[currentCategoryIndex];
            let tableHTML = `<h3>${category.toUpperCase()}</h3>
                            <table>
                                <thead>
                                    <tr>
                                        <th class="name-col">Name</th>
                                        <th>Pts</th><th>Lvl</th><th>Lines</th>
                                        <th>S</th><th>D</th><th>T</th><th>Tet</th>
                                        <th class="date-col">Date</th>
                                    </tr>
                                </thead><tbody>`;
            
            const scoresToDisplay = (highScores[category] || []).filter(scoreItem => {
                if (category === "Most Tetrises") return (scoreItem.tetrises || 0) > 0;
                if (category === "Most Triple Lines") return (scoreItem.triples || 0) > 0;
                if (category === "Most Double Lines") return (scoreItem.doubles || 0) > 0;
                if (category === "Most Single Lines") return (scoreItem.singles || 0) > 0;
                // For points and level, you might still want to show if any score > 0, or level > 0
                if (category === "Most Points" && (scoreItem.points || 0) === 0 && (scoreItem.lines || 0) === 0) return false;
                if (category === "Highest Level" && (scoreItem.level || 0) === 0 && (scoreItem.lines || 0) === 0) return false;
                return true; 
            });

            if (scoresToDisplay.length === 0) {
                tableHTML += '<tr><td colspan="8" style="text-align:center;">No records yet for this category.</td></tr>';
            } else {
                scoresToDisplay.forEach((scoreItem) => {
                    tableHTML += `
                        <tr>
                            <td class="name-col">${scoreItem.name}</td>
                            <td>${scoreItem.points || 0}</td><td>${scoreItem.level || 0}</td><td>${scoreItem.lines || 0}</td>
                            <td>${scoreItem.singles || 0}</td><td>${scoreItem.doubles || 0}</td><td>${scoreItem.triples || 0}</td><td>${scoreItem.tetrises || 0}</td>
                            <td class="date-col">${scoreItem.date}</td>
                        </tr>`;
                });
            }
            tableHTML += '</tbody></table>';
            highScoresContent.innerHTML = tableHTML;
        }

        function closeHighScores() {
            isHighScoreScreenActive = false;
            highScoresDiv.classList.add("hidden");
            gameContainer.classList.remove("hidden");
            hideMessage(); 
            if (paused && !gameOver) { showMessage('PAUSED', 0, true); } 
            else if (gameOver && !isNameEntryActive) { showBottomMessage("Press START or ENTER to Play!"); } 
            else if (!gameLoopId && !gameOver && !paused) { showBottomMessage("Press START or ENTER to Play!"); } 
            else { hideBottomMessage(); }
        }
        
        function handleHighScoreKeys(e) { 
            e.preventDefault(); 
            handleHighScoreKeyPress(e.key.toLowerCase());
        }
        
        function handleHighScoreKeyPress(keyAction) { 
            switch (keyAction) {
                case 'arrowleft':
                    currentCategoryIndex = (currentCategoryIndex - 1 + highScoreCategories.length) % highScoreCategories.length;
                    displayHighScores(); break;
                case 'arrowright':
                    currentCategoryIndex = (currentCategoryIndex + 1) % highScoreCategories.length;
                    displayHighScores(); break;
                case 'b': closeHighScores(); break;
            }
        }

        function addHighScore(category, name, valueOrDetailsObject, detailsObjectIfSeparate) {
            let actualValue;
            let actualDetails;

            if (typeof valueOrDetailsObject === 'object' && valueOrDetailsObject !== null && !detailsObjectIfSeparate) {
                // If first argument is the details object, extract the relevant value for the category
                actualDetails = valueOrDetailsObject;
                switch (category) {
                    case "Most Points": actualValue = actualDetails.points; break;
                    case "Highest Level": actualValue = actualDetails.level; break;
                    case "Most Tetrises": actualValue = actualDetails.tetrises; break;
                    case "Most Triple Lines": actualValue = actualDetails.triples; break;
                    case "Most Double Lines": actualValue = actualDetails.doubles; break;
                    case "Most Single Lines": actualValue = actualDetails.singles; break;
                    default: actualValue = 0;
                }
            } else {
                // Old way: value is passed as third arg, details as fourth
                actualValue = valueOrDetailsObject;
                actualDetails = detailsObjectIfSeparate;
            }
            
            const newScore = { name, value: actualValue || 0, date: new Date().toLocaleDateString() };
            const detailKeys = ['level', 'points', 'lines', 'singles', 'doubles', 'triples', 'tetrises'];
            detailKeys.forEach(key => {
                newScore[key] = actualDetails[key] || 0;
            });

            if (!highScores[category]) highScores[category] = []; 
            highScores[category].push(newScore);
            highScores[category].sort((a, b) => (b.value || 0) - (a.value || 0)); 
            if (highScores[category].length > 10) highScores[category].pop(); 
            saveHighScores();
        }


        function enterName(callback) { /* ... unchanged ... */ 
            const name = ["A", "A", "A"]; let currentIndex = 0;
            function updateNameDisplay() { showMessage(`GAME OVER!<br>Enter Name: ${name.join("")}<br>(↑/↓, Enter/→, ←, Esc to Skip)`, 0, true); }
            function nameEntryKeyDown(e) {
                if (!isNameEntryActive) { document.removeEventListener("keydown", nameEntryKeyDown, true); return; }
                e.preventDefault(); e.stopPropagation(); 
                switch(e.key.toLowerCase()) { 
                    case "arrowup": name[currentIndex] = String.fromCharCode(((name[currentIndex].charCodeAt(0) - 65 + 1) % 26) + 65); break;
                    case "arrowdown": name[currentIndex] = String.fromCharCode(((name[currentIndex].charCodeAt(0) - 65 - 1 + 26) % 26) + 65); break;
                    case "arrowleft": if (currentIndex > 0) currentIndex--; break;
                    case "arrowright":
                         if (currentIndex < 2) currentIndex++;
                         else { document.removeEventListener("keydown", nameEntryKeyDown, true); callback(name.join("")); return; }
                        break;
                    case "enter":
                        if (currentIndex < 2) currentIndex++;
                        else { document.removeEventListener("keydown", nameEntryKeyDown, true); callback(name.join("")); return; }
                        break;
                    case "escape": document.removeEventListener("keydown", nameEntryKeyDown, true); callback(null); return;
                }
                updateNameDisplay();
            }
            document.addEventListener("keydown", nameEntryKeyDown, true);
            updateNameDisplay(); 
        }

        document.getElementById("high-scores-button").addEventListener("click", () => {
            if (isNameEntryActive) return; 
            if (!isHighScoreScreenActive) {
                if (!gameOver && !paused && gameLoopId) pauseGame(); 
                displayHighScores();
            } else { closeHighScores(); }
        });
        
        function initGame() { /* ... unchanged ... */ 
            canvas.width = COLS * BLOCK_SIZE; canvas.height = ROWS * BLOCK_SIZE;
            nextCanvas.width = NEXT_COLS * BLOCK_SIZE * 0.8; nextCanvas.height = NEXT_ROWS * BLOCK_SIZE * 0.8;
            context.scale(1, 1); nextContext.scale(1, 1);
            showBottomMessage("Press START or ENTER to Play!"); hideMessage(); 
            pauseButton.disabled = true; pauseButton.textContent = "PAUSE";
            muteButton.textContent = isMusicMuted ? "MUSIC: OFF" : "MUSIC: ON";
            board = createBoard(); drawBoard();
            nextContext.fillStyle = COLORS.BACKGROUND; nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            isHighScoreScreenActive = false; isNameEntryActive = false;
            gameContainer.classList.remove('hidden'); highScoresDiv.classList.add('hidden'); 
        }
        initGame();
    </script>
</body>
</html>